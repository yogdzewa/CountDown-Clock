C51 COMPILER V9.60.0.0   USER_CALLBACK                                                     07/04/2022 09:06:45 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USER_CALLBACK
OBJECT MODULE PLACED IN .\output\user_callback.obj
COMPILER INVOKED BY: E:\Keil_v5\C51\BIN\C51.EXE source\user_callback.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\inc) DEBUG OBJE
                    -CTEXTEND PRINT(.\list\user_callback.lst) TABS(2) OBJECT(.\output\user_callback.obj)

line level    source

   1          #include "common_include.h"
   2          #include "help_func.h"
   3          #include "display_decode.h"
   4          #include "callback.h"
   5          
   6          // uint time_cur = 0;
   7          uchar led_pos = 1;
   8          pdata struct_DS1302_RTC clock_base;
   9          pdata struct_DS1302_RTC clock_cur;
  10          uint clock_base_totalsec;
  11          uint clock_cur_totalsec;
  12          bit set_time_flag;
  13          pdata struct_ADC adc_res;
  14          uchar adc_cnt;
  15          uint adc_acc;
  16          pdata uint light_base;
  17          pdata uint light_cur;
  18          uchar light_acc;
  19          bit time_out_flag; // time out led rotate indicator
  20          bit time_stop_flag;
  21          bit seg_rop_flag;     // seg indicator flag
  22          uchar light_array[6]; // seg display register
  23          uchar timer_array[6]; // seg dispaly register
  24          struct_time_diff time_diff_tmp;
  25          bit vibra_flag;
  26          bit seg_time_adjust_flag;
  27          bit rest_flag;
  28          bit rest_time_adjust_flag;
  29          bit startup_flag = 1;
  30          pdata uchar nvm_write_cnt = 3;
  31          XDATA char info[2] = {0xff, 0x0a};
  32          // reset the timer start
  33          #undef pdata
  34          void on_btn1_down()
  35          {
  36   1          clock_base = RTC_Read();
  37   1          time_out_flag = 0;
  38   1          time_stop_flag = 0;
  39   1          clock_base_totalsec = ((clock_base.second & 0x70) >> 4) * 10 + (clock_base.second & 0x0F);
  40   1          clock_base_totalsec += (((clock_base.minute & 0x70) >> 4) * 10 + (clock_base.minute & 0x0F)) * 60;
  41   1          clock_base_totalsec += (((clock_base.hour & 0x70) >> 4) * 10 + (clock_base.hour & 0x0F)) * 3600;
  42   1          if (!rest_flag)
  43   1          {
  44   2              TIME_LIMIT_ALLSEC = TIME_RELD_H * 3600;
  45   2              TIME_LIMIT_ALLSEC += TIME_RELD_M * 60;
  46   2              TIME_LIMIT_ALLSEC += TIME_RELD_S;
  47   2          }
  48   1          else
  49   1          {
  50   2              TIME_LIMIT_ALLSEC = TIME_REST_M * 60;
  51   2              TIME_LIMIT_ALLSEC += 5;
  52   2          }
  53   1      }
  54          #define dec(s, n) s##_array[n]
C51 COMPILER V9.60.0.0   USER_CALLBACK                                                     07/04/2022 09:06:45 PAGE 2   

  55          void on_btn2_down()
  56          { // set Rop light base
  57   1          light_base = adc_res.Rop;
  58   1          light_array[2] = light_base / 100;
  59   1          light_array[1] = light_base % 100 / 10;
  60   1          light_array[0] = light_base % 10;
  61   1          seg_rop_flag = 1;
  62   1      
  63   1          // for test uart
  64   1          // content: 0xa0 -> lockscreen
  65   1          Uart1Print(info, (uint)1);
  66   1      }
  67          void on_btn2_up() { seg_rop_flag = 0; }
  68          void on_btn3_down()
  69          { // adjust time interval
  70   1          seg_time_adjust_flag = 1;
  71   1          rest_time_adjust_flag = 0;
  72   1      }
  73          void on_nav_down()
  74          {
  75   1          if (seg_time_adjust_flag || rest_time_adjust_flag)
  76   1          {
  77   2              seg_time_adjust_flag = rest_time_adjust_flag = 0;
  78   2              // store TIME_RELD_** into M24C02
  79   2              // H -> 0x00, M -> 0x01, S -> 0x02, REST_M -> 0x03
  80   2              // the time interval is critical, so set the flag here
  81   2              //(for time callback function to countdown)
  82   2              M24C02_Write(0, TIME_RELD_H);
  83   2              delay_ms(10);
  84   2              M24C02_Write(1, TIME_RELD_M);
  85   2              delay_ms(10);
  86   2              M24C02_Write(2, TIME_RELD_S);
  87   2              delay_ms(10);
  88   2              M24C02_Write(3, TIME_REST_M);
  89   2              on_btn1_down();
  90   2          }
  91   1          else
  92   1          {
  93   2              // if ((startup_flag = ~startup_flag) == 1)
  94   2              //     (CLK_DIV = CLK_DIV | 0x07), rest_flag = 0, on_btn1_down();
  95   2              // else
  96   2              //     CLK_DIV = CLK_DIV & 0xf8;
  97   2              if ((startup_flag = ~startup_flag) == 1)
  98   2                  rest_flag = 0, on_btn1_down();
  99   2          }
 100   1      }
 101          #define TIME_INTERVAL 5
 102          #define RTIME_INTERVAL 2
 103          #define TIME_ADD (TIME_RELD_M + TIME_INTERVAL)
 104          #define TIME_ABSTRACT (TIME_RELD_M - TIME_INTERVAL)
 105          #define RTIME_ABSTRACT (TIME_REST_M - RTIME_INTERVAL)
 106          #define RTIME_ADD (TIME_REST_M + RTIME_INTERVAL)
 107          void on_downbtn_down()
 108          {
 109   1          if (seg_time_adjust_flag)
 110   1          {
 111   2              TIME_RELD_M = (TIME_ABSTRACT < (uchar)60) ? TIME_ABSTRACT : (TIME_RELD_H--, ((uchar)60 + TIME_ABST
             -RACT));
 112   2              TIME_RELD_H = TIME_RELD_H % 55;
 113   2          }
 114   1          else if (rest_time_adjust_flag)
 115   1              TIME_REST_M = (RTIME_ABSTRACT < (uchar)60) ? RTIME_ABSTRACT : ((uchar)60 + RTIME_ABSTRACT);
C51 COMPILER V9.60.0.0   USER_CALLBACK                                                     07/04/2022 09:06:45 PAGE 3   

 116   1      }
 117          void on_upbtn_down()
 118          {
 119   1          if (seg_time_adjust_flag)
 120   1          {
 121   2              TIME_RELD_M = (TIME_ADD < (uchar)60) ? TIME_ADD : (TIME_RELD_H++, (TIME_ADD - (uchar)60));
 122   2              TIME_RELD_H = TIME_RELD_H % 55;
 123   2          }
 124   1          else if (rest_time_adjust_flag)
 125   1              TIME_REST_M = (RTIME_ADD < (uchar)60) ? RTIME_ADD : (RTIME_ADD - (uchar)60);
 126   1      }
 127          void on_leftbtn_down()
 128          {
 129   1          if (rest_time_adjust_flag | seg_time_adjust_flag)
 130   1          {
 131   2              rest_time_adjust_flag = seg_time_adjust_flag;
 132   2              seg_time_adjust_flag = ~seg_time_adjust_flag;
 133   2          }
 134   1      }
 135          void on_rightbtn_down()
 136          {
 137   1          // SetBeep(8000, 5);
 138   1          if (rest_time_adjust_flag | seg_time_adjust_flag)
 139   1          {
 140   2              rest_time_adjust_flag = seg_time_adjust_flag;
 141   2              seg_time_adjust_flag = ~seg_time_adjust_flag;
 142   2          }
 143   1      }
 144          
 145          #undef TIME_ADD
 146          #undef RTIME_ADD
 147          #undef RTIME_ABSTRACT
 148          #undef TIME_ABSTRACT
 149          void on_sensor_vib()
 150          {
 151   1          // SetBeep(30, 1);
 152   1          if (!rest_flag)
 153   1              if (TIME_LIMIT_ALLSEC - 5 * 60 >= 0)
 154   1                  TIME_LIMIT_ALLSEC -= 5 * 60;
 155   1              else
 156   1                  TIME_LIMIT_ALLSEC %= 60;
 157   1          else
 158   1          {
 159   2              if (TIME_LIMIT_ALLSEC - 2 * 60 >= 0)
 160   2                  TIME_LIMIT_ALLSEC -= 2 * 60;
 161   2              else
 162   2                  TIME_LIMIT_ALLSEC %= 60;
 163   2          }
 164   1      }
 165          // read real time clock, and reverse the led(for test function)
 166          void on_timer_100ms()
 167          {
 168   1          if (!startup_flag)
 169   1              return;
 170   1          if (!time_stop_flag)
 171   1          {
 172   2              clock_cur = RTC_Read();
 173   2              clock_cur_totalsec = ((clock_cur.second & 0x70) >> 4) * 10 + (clock_cur.second & 0x0F);
 174   2              clock_cur_totalsec += (((clock_cur.minute & 0x70) >> 4) * 10 + (clock_cur.minute & 0x0F)) * 60;
 175   2              clock_cur_totalsec += (((clock_cur.hour & 0x70) >> 4) * 10 + (clock_cur.hour & 0x0F)) * 3600;
 176   2              // following function modifies @time_diff_tmp variable
 177   2              time_diff_count_down();
C51 COMPILER V9.60.0.0   USER_CALLBACK                                                     07/04/2022 09:06:45 PAGE 4   

 178   2              timer_array[1] = time_diff_tmp.second / 10;
 179   2              timer_array[0] = time_diff_tmp.second % 10;
 180   2      
 181   2              timer_array[3] = time_diff_tmp.minute / 10;
 182   2              timer_array[2] = time_diff_tmp.minute % 10;
 183   2      
 184   2              timer_array[5] = time_diff_tmp.hour / 10;
 185   2              timer_array[4] = time_diff_tmp.hour % 10;
 186   2              if (time_diff_tmp.minute == 0 && time_diff_tmp.hour == 0 && time_diff_tmp.second <= 20)
 187   2              {
 188   3                  time_out_flag = 1;
 189   3                  if (time_diff_tmp.second == 0)
 190   3                  {
 191   4                      time_stop_flag = 1;
 192   4                      SetBeep(10000, 1);
 193   4                  }
 194   3              }
 195   2          }
 196   1          // judge rop diff
 197   1          if (((int)light_base - (int)light_cur > 10))
 198   1              light_acc++;
 199   1          else
 200   1          {
 201   2              if (light_acc >= 2 && light_acc <= 6)
 202   2              {
 203   3                  time_out_flag = 0;
 204   3                  if (!rest_flag)
 205   3                      TIME_LIMIT_ALLSEC += 5 * 60;
 206   3                  else
 207   3                      TIME_LIMIT_ALLSEC += 2 * 60;
 208   3              }
 209   2              else if (light_acc >= 7)
 210   2                  rest_flag = ~rest_flag, on_btn1_down();
 211   2              light_acc = 0;
 212   2          }
 213   1      }
 214          void on_event_adc()
 215          {
 216   1          adc_res = GetADC();
 217   1          adc_cnt++;
 218   1          if (adc_cnt == 30)
 219   1          {
 220   2              light_cur = (adc_acc + 15) / 30;
 221   2              light_array[5] = light_cur / 100;
 222   2              light_array[4] = light_cur % 100 / 10;
 223   2              light_array[3] = light_cur % 10;
 224   2              adc_cnt = 0;
 225   2              adc_acc = 0;
 226   2          }
 227   1          else
 228   1              adc_acc += adc_res.Rop;
 229   1      }
 230          
 231          // void on_btn3_up() {}
 232          // void on_timer_1ms() {}
 233          // void on_timer_10ms() {}
 234          // void on_timer_1sec() {}
 235          void on_btn1_up() {}
 236          // void on_nav_up() {}
 237          // void on_downbtn_up() {}
 238          // void on_upbtn_up() {}
 239          // void on_leftbtn_up() {}
C51 COMPILER V9.60.0.0   USER_CALLBACK                                                     07/04/2022 09:06:45 PAGE 5   

 240          // void on_rightbtn_up() {}
 241          // void on_ir_rx() {}
 242          // void on_uart1_rx() {}
 243          // void on_uart2_rx() {}
 244          // void on_sensor_hall() {}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1115    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2    ----
   PDATA SIZE       =     29    ----
   DATA SIZE        =     24    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      9    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.60.0.0   USER_CALLBACK                                                     07/02/2022 00:48:28 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USER_CALLBACK
OBJECT MODULE PLACED IN .\output\user_callback.obj
COMPILER INVOKED BY: E:\Keil_v5\C51\BIN\C51.EXE source\user_callback.c OPTIMIZE(8,SPEED) INCDIR(.\inc) PRINT(.\list\user
                    -_callback.lst) TABS(2) OBJECT(.\output\user_callback.obj)

line level    source

   1          #include "common_include.h"
   2          #include "help_func.h"
   3          #include "display_decode.h"
   4          #include "callback.h"
   5          
   6          uint time_cur = 0;
   7          uchar led_pos = 1;
   8          pdata struct_DS1302_RTC clock_base;
   9          pdata struct_DS1302_RTC clock_cur;
  10          bit set_time_flag;
  11          pdata struct_ADC adc_res;
  12          uchar adc_cnt;
  13          uint adc_acc;
  14          pdata uint light_base;
  15          pdata uint light_cur;
  16          uchar light_acc;
  17          bit time_out_flag; // time out led rotate indicator
  18          bit time_stop_flag;
  19          bit seg_rop_flag;     // seg indicator flag
  20          uchar light_array[6]; // seg display register
  21          uchar timer_array[6]; // seg dispaly register
  22          struct_time_diff time_diff_tmp;
  23          bit vibra_flag;
  24          bit seg_time_adjust_flag;
  25          bit rest_flag;
  26          bit rest_time_adjust_flag;
  27          bit startup_flag = 1;
  28          // reset the timer start
  29          void on_btn1_down()
  30          {
  31   1          clock_base = RTC_Read();
  32   1          time_out_flag = 0;
  33   1          time_stop_flag = 0;
  34   1          clock_base.second = ((clock_base.second & 0x70) >> 4) * 10 + (clock_base.second & 0x0F);
  35   1          clock_base.minute = ((clock_base.minute & 0x70) >> 4) * 10 + (clock_base.minute & 0x0F);
  36   1          clock_base.hour = ((clock_base.hour & 0x70) >> 4) * 10 + (clock_base.hour & 0x0F);
  37   1          if (!rest_flag)
  38   1          {
  39   2              TIME_LIMIT_hour = TIME_RELD_H;
  40   2              TIME_LIMIT_minute = TIME_RELD_M;
  41   2              TIME_LIMIT_second = TIME_RELD_S;
  42   2          }
  43   1          else
  44   1          {
  45   2              TIME_LIMIT_minute = TIME_REST_M;
  46   2              TIME_LIMIT_hour = 0;
  47   2              TIME_LIMIT_second = 21;
  48   2          }
  49   1      }
  50          #define dec(s, n) s##_array[n]
  51          void on_btn2_down()
  52          { // set Rop light base
  53   1          light_base = adc_res.Rop;
  54   1          light_array[2] = light_base / 100;
C51 COMPILER V9.60.0.0   USER_CALLBACK                                                     07/02/2022 00:48:28 PAGE 2   

  55   1          light_array[1] = light_base % 100 / 10;
  56   1          light_array[0] = light_base % 10;
  57   1          // Seg7Print(dec(light, 2), dec(light, 1), dec(light, 0), 36, dec(light, 5), dec(light, 4), dec(light,
             - 3));
  58   1          seg_rop_flag = 1;
  59   1      }
  60          void on_btn2_up() { seg_rop_flag = 0; }
  61          void on_btn3_down()
  62          { // adjust time interval
  63   1          seg_time_adjust_flag = 1;
  64   1          rest_time_adjust_flag = 0;
  65   1      }
  66          void on_nav_down()
  67          {
  68   1          if (seg_time_adjust_flag || rest_time_adjust_flag)
  69   1          {
  70   2              seg_time_adjust_flag = rest_time_adjust_flag = 0;
  71   2              on_btn1_down();
  72   2          }
  73   1          else
  74   1          {
  75   2              // if ((startup_flag = ~startup_flag) == 1)
  76   2              //     (CLK_DIV = CLK_DIV | 0x07), rest_flag = 0, on_btn1_down();
  77   2              // else
  78   2              //     CLK_DIV = CLK_DIV & 0xf8;
  79   2              if ((startup_flag = ~startup_flag) == 1)
  80   2                  rest_flag = 0, on_btn1_down();
  81   2          }
  82   1      }
  83          #define TIME_INTERVAL 5
  84          #define RTIME_INTERVAL 2
  85          #define TIME_ADD (TIME_RELD_M + TIME_INTERVAL)
  86          #define TIME_ABSTRACT (TIME_RELD_M - TIME_INTERVAL)
  87          #define RTIME_ABSTRACT (TIME_REST_M - RTIME_INTERVAL)
  88          #define RTIME_ADD (TIME_REST_M + RTIME_INTERVAL)
  89          void on_downbtn_down()
  90          {
  91   1          if (seg_time_adjust_flag)
  92   1          {
  93   2              TIME_RELD_M = (TIME_ABSTRACT < (uchar)60) ? TIME_ABSTRACT : (TIME_RELD_H--, ((uchar)60 + TIME_ABST
             -RACT));
  94   2              TIME_RELD_H = TIME_RELD_H % 55;
  95   2          }
  96   1          else if (rest_time_adjust_flag)
  97   1              TIME_REST_M = (RTIME_ABSTRACT < (uchar)60) ? RTIME_ABSTRACT : ((uchar)60 + RTIME_ABSTRACT);
  98   1      }
  99          void on_upbtn_down()
 100          {
 101   1          if (seg_time_adjust_flag)
 102   1          {
 103   2              TIME_RELD_M = (TIME_ADD < (uchar)60) ? TIME_ADD : (TIME_RELD_H++, (TIME_ADD - (uchar)60));
 104   2              TIME_RELD_H = TIME_RELD_H % 55;
 105   2          }
 106   1          else if (rest_time_adjust_flag)
 107   1              TIME_REST_M = (RTIME_ADD < (uchar)60) ? RTIME_ADD : (RTIME_ADD - (uchar)60);
 108   1      }
 109          void on_leftbtn_down()
 110          {
 111   1          if (rest_time_adjust_flag | seg_time_adjust_flag)
 112   1          {
 113   2              rest_time_adjust_flag = seg_time_adjust_flag;
 114   2              seg_time_adjust_flag = ~seg_time_adjust_flag;
C51 COMPILER V9.60.0.0   USER_CALLBACK                                                     07/02/2022 00:48:28 PAGE 3   

 115   2          }
 116   1      }
 117          void on_rightbtn_down()
 118          {
 119   1          // SetBeep(8000, 5);
 120   1          if (rest_time_adjust_flag | seg_time_adjust_flag)
 121   1          {
 122   2              rest_time_adjust_flag = seg_time_adjust_flag;
 123   2              seg_time_adjust_flag = ~seg_time_adjust_flag;
 124   2          }
 125   1      }
 126          
 127          #undef TIME_ADD
 128          #undef RTIME_ADD
 129          #undef RTIME_ABSTRACT
 130          #undef TIME_ABSTRACT
 131          #define TIME_ABSTRACT (TIME_LIMIT_minute - TIME_INTERVAL)
 132          #define RTIME_ABSTRACT (TIME_LIMIT_minute - RTIME_INTERVAL)
 133          #define TIME_ADD (TIME_LIMIT_minute + TIME_INTERVAL)
 134          #define RTIME_ADD (TIME_LIMIT_minute + RTIME_INTERVAL)
 135          void on_sensor_vib()
 136          {
 137   1          SetBeep(40, 1);
 138   1          if (!rest_flag)
 139   1              TIME_LIMIT_minute = (TIME_ABSTRACT < (uchar)60) ? TIME_ABSTRACT : ((TIME_LIMIT_hour ? (TIME_LIMIT_
             -hour--, (TIME_ABSTRACT + (uchar)60)) : 0));
 140   1          else
 141   1              TIME_LIMIT_minute = (RTIME_ABSTRACT < (uchar)60) ? RTIME_ABSTRACT : (RTIME_ABSTRACT + (uchar)60);
 142   1      }
 143          // read real time clock, and reverse the led(for test function)
 144          void on_timer_100ms()
 145          {
 146   1          if (!startup_flag)
 147   1              return;
 148   1          if (!time_stop_flag)
 149   1          {
 150   2              clock_cur = RTC_Read();
 151   2              clock_cur.second = ((clock_cur.second & 0x70) >> 4) * 10 + (clock_cur.second & 0x0F);
 152   2              clock_cur.minute = ((clock_cur.minute & 0x70) >> 4) * 10 + (clock_cur.minute & 0x0F);
 153   2              clock_cur.hour = ((clock_cur.hour & 0x70) >> 4) * 10 + (clock_cur.hour & 0x0F);
 154   2              // following function modifies @time_diff_tmp variable
 155   2              time_diff_count_down(clock_base, clock_cur);
 156   2              timer_array[1] = time_diff_tmp.second / 10;
 157   2              timer_array[0] = time_diff_tmp.second % 10;
 158   2      
 159   2              timer_array[3] = time_diff_tmp.minute / 10;
 160   2              timer_array[2] = time_diff_tmp.minute % 10;
 161   2      
 162   2              timer_array[5] = time_diff_tmp.hour / 10;
 163   2              timer_array[4] = time_diff_tmp.hour % 10;
 164   2              if (time_diff_tmp.minute == 0 && time_diff_tmp.hour == 0 && time_diff_tmp.second <= 20)
 165   2              {
 166   3                  time_out_flag = 1;
 167   3                  if (time_diff_tmp.second == 0)
 168   3                  {
 169   4                      time_stop_flag = 1;
 170   4                      SetBeep(10000, 1);
 171   4                  }
 172   3              }
 173   2          }
 174   1          // judge rop diff
 175   1          if (((int)light_base - (int)light_cur > 10))
C51 COMPILER V9.60.0.0   USER_CALLBACK                                                     07/02/2022 00:48:28 PAGE 4   

 176   1              light_acc++;
 177   1          else
 178   1          {
 179   2              if (light_acc >= 2 && light_acc <= 6)
 180   2              {
 181   3                  time_out_flag = 0;
 182   3                  if (!rest_flag)
 183   3                      TIME_LIMIT_minute = (TIME_ADD < (uchar)60) ? TIME_ADD : (TIME_LIMIT_hour++, (TIME_ADD - (u
             -char)60));
 184   3                  else
 185   3                      TIME_LIMIT_minute = (RTIME_ADD < (uchar)60) ? RTIME_ADD : (RTIME_ADD - (uchar)60);
 186   3              }
 187   2              else if (light_acc >= 7)
 188   2                  rest_flag = ~rest_flag, on_btn1_down();
 189   2              light_acc = 0;
 190   2          }
 191   1      }
 192          void on_event_adc()
 193          {
 194   1          adc_res = GetADC();
 195   1          adc_cnt++;
 196   1          if (adc_cnt == 30)
 197   1          {
 198   2              light_cur = (adc_acc + 15) / 30;
 199   2              light_array[5] = light_cur / 100;
 200   2              light_array[4] = light_cur % 100 / 10;
 201   2              light_array[3] = light_cur % 10;
 202   2              adc_cnt = 0;
 203   2              adc_acc = 0;
 204   2          }
 205   1          else
 206   1              adc_acc += adc_res.Rop;
 207   1      }
 208          
 209          // void on_btn3_up() {}
 210          // void on_timer_1ms() {}
 211          // void on_timer_10ms() {}
 212          // void on_timer_1sec() {}
 213          void on_btn1_up() {}
 214          // void on_nav_up() {}
 215          // void on_downbtn_up() {}
 216          // void on_upbtn_up() {}
 217          // void on_leftbtn_up() {}
 218          // void on_rightbtn_up() {}
 219          // void on_ir_rx() {}
 220          // void on_uart1_rx() {}
 221          // void on_uart2_rx() {}
 222          // void on_sensor_hall() {}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    987    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     28    ----
   DATA SIZE        =     22    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      9    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
